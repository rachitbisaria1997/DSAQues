	
	
	@FunctionalInterface   useful in writing lambda expressions and method reference.concise, readable code. 
	public interface CalcOperation{
	
		double operation(int a, int b);


	}
	
	psvm()
	{
	
		CalcOperation subtraction = (p,q) -> {
			return p - q;
		};
		
		CalcOperation addition = (p,q) -> {
			return p + q;
		};
		
		double value = subtraction.operation(30,12);
		SOP(value);
		
		double val = addition.operation(10,20);
		SOP(val1);
	
	}
	
	interface abc{
		default void methodName()
		{
			SOP("COMMON");
		}	
	}
	
	class Car implements abc{
		
	}
	
	class B {
		
		psvm()
		{
			Car c = new Car();
			c.methodName();
		
		}
	}
	
	Predicate<Integer> ageCheck = age -> age > 30;
	
	SOP(ageCheck.test(32)); true
	
	SOP(ageCheck.test(2)); true
	
	
	if(ageCheck.test(44)){
		SOP("eligible");
	}
	else {
		SOP("not eligible");
	}
	
	 Employee e1 = new Employee();
        e1.setId(111);
        e1.setSalary(27000);
		
	Predicate<Employee> empSalaryCheck = emp -> emp.getSalary() > 2000;
	
	if(empSalaryCheck.test(e1)){
		SOP("above 20000");
	}
	else{
		SOP("below 20000");
	}
	
	String [] words = new String[8];
	words[5] = "jij";
	
	Optional<String> checkNull = Optional.ofNullable(words[5]);
	if(checkNull.isPresent())
	{
		String name =  checkNull.get();
		SOP(name.toUpperCase());
		SOP(name.isPresent());
	}	
	else{
	SOP("not present");
	}
	
	
	String name = "rachit bisaria";
	Optional<String> value = null;
	
	if(name == null)
	{
		value = Optional.empty();
	}
	else{
		value = Optional.of(name);
	}
	
	
	Optional<String> nameContainer = getName();
	nameContainer.isPresent(val -> SOP(val.toUpperCase()));
	
	nameContainer.ifPresentOrElse(
		
		(val) -> {
			SOP(val.toUpperCase());
		},
		() -> {
			SOP("value is not present");
		}
	);
	
	public class MethodReferenceDemo {

    //Method references are a shorthand notation of lambda expressions to call a method directly.

    public void print(String s) {
        System.out.println(s);
    }

    public void display(String msg){
        System.out.println("instance print: "+ msg);
    }

    public static void main(String[] args) {

        Demo demo = new Demo();
        List<String> list = Arrays.asList("Apple", "Banana");

        list.forEach(MethodRefDemo::print);

        List<String> names = Arrays.asList("Zara", "Liam", "Noah", "Emma");
        names.sort(String::compareToIgnoreCase);
        names.forEach(System.out::println);

    }


	}
	
	
	List<Integer> numbers = Arrays.asList(2,4,6,8,10,11,12,14,15);
	
	boolean containsPrime = numbers.stream().anyMatch(StreamExamples::isPrime);
	
	public static boolean isPrime(int number){

        if(number < 1){
            return false;
        }

        for(int i=2; i< number; i++){
            if(number % i == 0){
                return false;
            }
        }
        return true;

    }
	
	List<Integer> list1 = Arrays.asList(1,2, 3, 5, 7, 9);
    List<Integer> list2 = Arrays.asList(2, 4, 6, 8, 10);
	
	List<Integer> mergd = Stream.concat(list1.stream(), list2.stream()).sorted().collect(Collectors.toList());
	SOP(mergd);
	
	 		
				
	Optional<String> longestString = strings.stream().max(Comparator.comparingInt(String::length));
	
	List<Integer> numbersWithDuplicates = Arrays.asList(1, 2, 3, 2, 4, 1, 5, 6, 5);
	
	List<Integer> uniqelem = numbersWithDuplicates.stream().distinct().collect(Collectors.toList());
	int[] array = {4, 2, 7, 1, 5, 3, 6};
        int k=3;
		
		
	int kthsmallest = Arrays.stream(array).sorted().skip(k-1).findFirst().orElse(-1);
	
	List<String> words = Arrays.asList("apple", "banana", "apple", "cherry",
                "banana", "apple");
				
	Map<String, Long> wordFreq = words.stream().collect(Collectors.groupingBY(Function.identity(), Collectors.counting()));
	
	
	
	
	// Collections framework

	HashMap = doesn't maintain order and not thread safe.

	1. ConcurrentHashMap - its thread safe, doesnt maintains order, and suitable for concurrency. Allows multiple threads to read and write concurrently
         without locking the entire map
	
	ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

        map.put("A", 1);
        map.put("B", 1);
        map.put("C", 1);

        System.out.println("value of A is "+ map.get("A"));

        map.remove("B");
        map.putIfAbsent("C++", 3);

        map.forEach((k, v) -> System.out.println(k + ":"+ v));
	
	2. ConcurrentSkipListMap  its thread safe, maintains order, and suitable for concurrency, maintains keys in natural order
	
		ConcurrentSkipListMap<String, Integer> map = new ConcurrentSkipListMap<>();
        map.put("apple", 1);
        map.put("banana", 2);
        map.put("jamun", 3);

        System.out.println(map);

        System.out.println("first key is "+ map.firstKey());
		
	3. EnumMap
		
		Map<Day, String> map = new EnumMap<>(Day.class);
		map.put(Day.MONDAY, "Gym");
        map.put(Day.TUESDAY, "Walk");
		
		enum Day {
			MONDAY, TUESDAY
		}
		
	3. linkedHashMap - preserves order in which keys were inserted.
	
		HashMap<String, Integer> linkedHashMap = new HashMap<>(11);
        linkedHashMap.put("orange", 6);
        linkedHashMap.put("apple", 5);
	
	4. Sorted Map - keys are sorted in ascending natural order
	
		SortedMap<Integer, String> map = new TreeMap<>();

        map.put(45, "vivek");
        map.put(55, "mohit");
	
	
	B. Set overview
	Set<Integer> set = new HashSet<>();
		set.add(12);
        set.add(15);
        set.add(25);
	SOP(set.contains(25));
	
	no guarantee of iteration order
	
	Set<String> set = new LinkedHashSet<>(); maintains insertion order 
	Set<String> set = new TreeSet<>();  maintains elements in sorted order
	
	C. Vectors
		
		// initial capacity is 5, capacityIncrement is 3
		
		Vector<Integer> vector = new Vector<>(5, 3);
        vector.add(1);
        vector.add(2);
        vector.add(3);

        System.out.println(vector.capacity());
        vector.add(4);

        for(int i=0; i<vector.size(); i++){
            System.out.println(vector.get(i));
        }
		
	D. LRUCache
	
	public class LRUCache <K, V> extends LinkedHashMap<K, V> {

  	  private int capacity;

   	 public LRUCache(int cap){
        	this.capacity = cap;
    	}

    	@Override
    	protected boolean removeEldestEntry(Map.Entry<K,V> eldest){
        return size() > capacity;
    	}

    	public static void main(String[] args) {

        LRUCache<String, Integer> studentMap = new LRUCache<>(3);
        studentMap.put("bob", 99);
        studentMap.put("alice", 101);
        studentMap.put("ram", 199);
        studentMap.put("vipul", 89);

        // here capacity is 3, least recently used is bob hence its removed from studentmap

        System.out.println(studentMap);
   	 }

	}	
	



	
	Q. singleton classes allows only 1 instance to be created and provides global access point to it. ensures single instance is created.
       Keep a single, consistent configuration object for the whole application (e.g., DB configs, app settings). Logger instance
	
		public class MySingleton {

			// Static gives global access to the instance/method.
			private static final MySingleton instance = new MySingleton();

			// Private constructor to prevent external instantiation
			private MySingleton() {
				System.out.println("Singleton instance created");
			}

			// Public method to return the singleton instance
			public static MySingleton getInstance() {
				return instance;
			}

			public void showMessage() {
				System.out.println("Hello from Singleton");
			}
	   }
		
	class Main
	{
		psvm()
		{
			MySingleton obj1 = MySingleton.getInstance();
			MySingleton obj2 = MySingleton.getInstance();
			
			obj1.showMessage();
			SOP(obj1 == obj2) - true
		}
	}
	
	Q. difference between equals() and == in java
	== checks for memory reference while equals() checks for content
	
	Q. final keywords can be used in 4 contexts - final variable value cant be changed once assigned
		final method cannot be overriden. final class Cannot be extended/inherited. 
	
	Q. strings are immutable in java because of security reasons. to prevent tampering, safe to share strings between threads without synchronization.
	
	Q. adv of spring boot over SF. Spring boot has no XML, fast setup. comes with tomcat, jetty. it has actuators, health checks, metrics. rapid deployment using auto configuration.
	
	Q. annotations in spring boot
		@SpringBootApplication, @EnableAutoConfiguration, @ComponentScan, 


	SF - | Annotation        | Purpose                                                                    |
| ----------------- | -------------------------------------------------------------------------- |
| `@Component`      | Marks a class as a Spring-managed component.                               |
| `@Controller`     | Marks a class as a web controller (MVC).                                   |
| `@RestController` | Shortcut for `@Controller + @ResponseBody`. Used for REST APIs.            |
| `@Service`        | Marks a service class (business logic layer).                              |
| `@Repository`     | Marks a DAO/repository class (persistence layer). Also handles exceptions. |
| `@Autowired`      | Injects dependencies automatically by type.                                |
| `@Qualifier`      | Used with `@Autowired` to specify the bean by name.                        |
| `@Value`          | Injects values from `application.properties`.                              |
| `@Configuration`  | Declares a configuration class with bean definitions.                      |
| `@Bean`           | Defines a bean manually inside a config class.                             |


	@Configuration
	class AppConfig{
			
            @Bean
            public GreetingService greetingService()
            {
		return new GreetingService();
	    }
		
        }

	public class GreetingService {
 	public String greet(String name) {
        return "Hello, " + name + "!";
    	}
	}

	@Autowired
	private GreetingService greetService;

	SOP(greetService.greet("rachit"));   -> Hello, rachit
  

	Spring MVC - @GetMapping, @PostMapping, @PutMapping, @DeleteMapping, @RequestMapping, @PathVariable, @RequestBody, @ResponseBody


	Q. Life cycle of thread
	1. New -> Thread t = new Thread();
	2. Runnable - thread might be running or ready to run at any instant of time.
		t.start();
	3. blocked - thread is bloced when its trying to acquire a lock but lock is acquired by another thread. e.g., in synchronized blocks
	4. waiting - thread is waiting using wait()
	5. terminated - thread has finished execution.
	
	Q. what are servlets ?
	Servlet is a Java class that runs on a web server and handles HTTP requests and responses. its part of Java EE/ jakarta EE and used to create dynamic web pages.
		
		servlet listens at Url /hello
		When the server receives a GET request to /hello, the doGet() method is called.
		It responds with plain text:
		"Hello from servlet!"
		
		@WebServlet("/hello")
		public class HelloServlet extends HttpServlet {
			protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException {
		   res.getWriter().write("Hello from servlet!");
			}
		}
		
		Spring boot has lots of XML based config while Spring boot has min. it provided various mappings.
	
	Q. diff levels of caching - aching is used to store frequently accessed data in memory to improve performance
	1. in memory caching - data is stored in heap memory ex hashmap
	2. application level caching - Uses annotations like @Cacheable, @CachePut
	3. distributed caching - Data is cached across multiple servers., Suitable for microservices and scalable apps.
	
	Use @Cacheable to cache method results:
	
	@Service
	public class UserService {

		@Cacheable("users")
		public User getUserById(Long id) {
			simulateSlowService(); // Imagine DB or API call
			return userRepository.findById(id).orElse(null);
		}
	}
	

	Q. what is classpath in java
	classpath is the path which tells the JVM, java compiler where to look for 
		user defined classes, compiled .class files, jar files.
	if class is not found at classpath, ClassNotFOundException is thrown

	Q. what are class loaders. 
	class loader in java is part of JVM which loads the .class files compiled java byte code files into memory when needed.
	
	The JVM doesn't know about .class files until the class loader loads them.

		The loading process follows a three-step model:

		Loading ‚Äì Finds the .class file and loads bytecode into memory.

		Linking

		Verification: Ensures bytecode is valid and doesn't break security.

		Preparation: Allocates memory for static variables.

		Resolution: Replaces symbolic references with actual references.

		Initialization ‚Äì Static blocks and static variables are initialized.
	
		typed of class loaders:-
		1. bootstrap class loader - Loads core Java classes (java.lang, java.util, etc.)
		2. extension classloader - loads classes from lib/ext directory
		3. appl class loader - loads the classes from classpath.
		
		
		public class AppClassLoaderExample {

   	
		}
		ClassLoader classLoader = AppClassLoaderExample.class.getClassLoader();

C
		Class<?> userClass = classLoader.loadClass("AppClassLoaderExample");
		SOP(userClass.getName()); 
		

	Q. Alien obj = new Alien();
	   obj.setAid(101); obj.setAName("rachit"); obj.setColor('red');
	   
	   Configuration con = new Configuration().configure("hibernate.cfg.xml").addAnnotatedClass(Alien.class);
	   SessionFactory sf = con.buildSessionFactory():

		 a Session is the main interface between your Java application and the database. It represents a single unit of work and is responsible for persisting, retrieving, updating, and deleting Java objects mapped to database tables.p
	   
	   
	   Session sess = sf.openSession(): 
	   Transaction tx = sess.beginTransaction();
	   sess.save(tx);
	   
	   tx.commit();
	
	Q. activities done in DB design.
	Activities in Database Design:
		Requirements gathering

		Entity-relationship modeling

		Normalization

		Choosing primary/foreign keys

		Designing tables, constraints

		Indexing

		Security/access control

		Performance optimization
	
	Q. how to handle exceptions in spring boot, use COntrollerAdvise and ExceptionHandler
	
		@ControllerAdvice
		public class CloudVendorExceptionHandler {

			@ExceptionHandler(value = {CloudVendorNotFoundException.class})
			public ResponseEntity<Object> handleCloudVendorNotFoundException(CloudVendorNotFoundException cloudVendorNotFoundException)
			{
				CloudVendorException cloudVendorException = new CloudVendorException(
						cloudVendorNotFoundException.getMessage(),
						cloudVendorNotFoundException.getCause(),
						HttpStatus.NOT_FOUND
				);

				return new ResponseEntity<>(cloudVendorException,HttpStatus.NOT_FOUND);
			}

			// @ControllerAdvice tells Spring that this class will handle exceptions globally across all controllers.
			// @ExceptionHandler registers this method to be automatically invoked when a CloudVendorNotFoundException is thrown by any controller.
		}	
	
	Q. static class loading. happends at compile time. 
		// Car car = new Car(); // Car class is statically loaded
		
		dynamic class loading, happends at runtime.
		classname is not known at compile time.
		
		Class<?> clazz = Class.forName("com.example.Car");
		Object car = clazz.getDeclaredConstructor().newInstance();
		
	Q. Transactional 
	
	@Service
	public class BankService {

		@Autowired
		private AccountRepository accountRepository;

		@Transactional
		public void transferMoney(Long fromAccountId, Long toAccountId, double amount) {
			Account from = accountRepository.findById(fromAccountId).orElseThrow();
			Account to = accountRepository.findById(toAccountId).orElseThrow();

			from.setBalance(from.getBalance() - amount);
			to.setBalance(to.getBalance() + amount);

			accountRepository.save(from);
			accountRepository.save(to);

			// If any exception occurs, the entire transaction will be rolled back
		}
	}
	
	Q. types of DI
		Constructor Injection ‚úÖ Recommended

		Setter Injection

		Field Injection (with @Autowired) ‚Äì discouraged for testability
		
	Q. Immutable: Cannot change state after creation.
			Example: String, Integer
			
	    mutable objects - can be modified - ex Stringbuilder.
	
	Q. what is web server - 
		Web servers and application servers have distinct yet often complementary roles in delivering web content and applications. Web servers primarily handle HTTP requests and serve static content like HTML, CSS, and images ex nginx http server. Application servers, on the are designed to handle more complex tasks, such as processing user requests, executing business logic, interacting with 			databases, and generating dynamic content
		
	Q. how threads communicates with each other - using notify(), wait() objects.
	
	Q. git stash
		Temporarily saves uncommitted changes (tracked files) and restores a clean working directory.

		Useful when switching branches without committing WIP changes.
	
		git stash       # Save
		git stash pop   # Restore
	
	Q. what is return type of run() in runnable interface
	 void
	 
	Q. how to connect with multiple DB's/ schemas in JPA application.properties.. multiple DB configs
		spring.datasource.url=jdbc:mysql://localhost:3306/primary_db
		spring.datasource.username=root
		spring.datasource.password=pass

		second.datasource.url=jdbc:mysql://localhost:3306/secondary_db
		second.datasource.username=root
		second.datasource.password=pass
		
		@Configuration
		@EnableTransactionManagement
		public class PrimaryConfig{
		
			@Primary
			@Bean
			@ConfigurationProperties("spring.datasource")
			public DataSource primaryDataSource() {
				return DataSourceBuilder.create().build();
			}
		
		}
		
		@Configuration
		@EnableTransactionManagement
		public class SecondConfig{
		
			@Primary
			@Bean
			@Configuration("second.datasource")
			public DataSource primaryDataSource() {
				return DataSourceBuilder.create().build();
			}
		}
		
	
	Q. how to connect with diff environments
	
	create the profiles under src/main/resources
	application.properties ‚Üí Default config

	application-dev.properties ‚Üí Dev profile

	application-prod.properties ‚Üí Prod profile


application-dev.properties

	# ---------- Server Settings ----------
server.port=8081
server.servlet.context-path=/myapp

# ---------- Database Settings ----------
spring.datasource.url=jdbc:mysql://localhost:3306/dev_db
spring.datasource.username=dev_user
spring.datasource.password=dev_password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# ---------- JPA / Hibernate Settings ----------
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect

# ---------- Logging ----------
logging.level.root=INFO
logging.level.org.springframework.web=DEBUG
logging.file.name=logs/dev-app.log

# ---------- Custom Application Properties ----------
app.feature-x.enabled=true
app.service.timeout=5000

# ---------- Mail (example) ----------
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=your-email@gmail.com
spring.mail.password=your-password
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true



	we can activate a pprofile via application.properties file use here-> spring.profiles.active = dev


	Q. advantages of Inversion of control
	1. centralized config using annotations or XML. spring handles all the wiring via annotations or xml based.
	2. decouples object creation from business logic
	3. increases testability - we can use mock dependencies for easy unit testing
	
	Q. artificate type after build in spring boot
	default is jar file
	
	Q. Why is String immutable? - thread safe, security
	
	Q. thread pool management is done using ExecutorService. ExecutorService executorService = Executors.newFixedThreadPool(1);
		// max 1 thread can run
	
	Q. what is bean lifecycle
	scopes - singleton, prototype. singleton - one instance per spring container. prototype - new instance each time requested.
	
	lifecycle = dependency injection, postconstruct @postconstruct and then predestroy
	
	Q. @GetMapping("/search")
	   public ResponseEntity<?> search(@RequestParam String name, @RequestParam Integer age)
	   {	
		return userService.searchUser(name, age);
	   }

	   @GetMapping("/{id}")
    	   public User getUserById(@PathVariable Long id) {
        		return userService.getUserById(id);
    	  }

		// path variable is part of URL path, used for structured path data.
		// requestparam used for optional filters, search etc.

	Q. WHAT is SOAP API - its secure, transactional.all requests, responses are in XML format. can use HTTP, SMTP formats.
	// used for exchanging data in structured format. in XML format.
	
	
	SOAP request
	<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
					  xmlns:bank="http://bank.example.com/">
	   <soapenv:Header/>
	   <soapenv:Body>
		  <bank:getAccountBalance>
			 <bank:accountNumber>123456789</bank:accountNumber>
			 <bank:pin>1234</bank:pin>
		  </bank:getAccountBalance>
	   </soapenv:Body>
	  
	</soapenv:Envelope>
	
		SOAP response
		<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
                  xmlns:bank="http://bank.example.com/">
		<soapenv:Body>
		  <bank:getAccountBalanceResponse>
			 <bank:balance>25000.50</bank:balance>
		  </bank:getAccountBalanceResponse>
	   </soapenv:Body>
	</soapenv:Envelope>

	REST API
	REST API to fetch user details.
	
	REST Request. GET /api/users/123 HTTP/1.1
				  Host: example.com
				   Authorization: Bearer eyJhbGciOiJIUzI1...
	
	REST - It's lightweight, fast, and supports multiple formats (mostly JSON), ideal for modern applications and microservices.
	
	JSON response.
	{
	  "id": 123,
	  "name": "John Doe",
	  "email": "john.doe@example.com",
	  "createdAt": "2023-08-01T10:30:00Z"
	}
	
	Q.  Microservice to microservice communication
	2 ways - synchronous and asynchronous communication.
	
	Q. what are Rest templates. 
	it is used to call REST API's from your java application.
	
	1. GET request - 
	RestTemplate restTemplate = new RestTemplate();
	User user = restTemplate.getForObject("http://localhost:8080/users/1", User.class);
	
	2. POST request
	User newuser = new User("john", "doe");
	User createdUser = restTemplate.postForObject("http://localhost:8080/users", newUser, User.class);
	
	
	Q. different entity states in JPA
	transient - new object. not associated with any session
	persistent - using save(), persist()
	detached - no longer associated with any session
	removed - marked for deletion from DB.
	
	Q. what are diff states in JPA
	
	State	Description
	Transient	New object, not associated with persistence context
	Persistent	Associated with persistence context (e.g., after persist())
	Detached	Was persistent, now no longer in persistence context
	Removed	Marked for deletion from DB

	Q. to compile a java program
	javac Myprogram.java

	run the compiled code using java Myprogram
	
	Q. HashMap uses hashCode() to find bucket and equals() to resolve collisions.
	If you don‚Äôt override them for custom objects (as keys), even logically equal objects will go into different buckets, causing unexpected behavior (duplicate keys)
	
	Q. Deploying Java on Windows and Linux ‚Äî Separate Compilation?. java is platform independent lang
	1. compile once .class or .jar file nd run anywhere.
	
	Q. what are web filters. - component which intercepts requests/responses before reaching controller.
	used for loggin and authentication.
	
	@WebFilter("/api/*")
	public class MyFilter implements Filter{
		
		public void doFilter(...)
		{
			chain.doFilter(request, response);
		}
	}
	
	Q. what are webfilters -  it intercepts http requests going to path matching /api/*. 
	
	@WebFilter("/api/*")
	public class MyFilter implements Filter{
		
		@Override
		public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {

        // ‚úÖ Pre-processing logic (before the request hits controller)
        System.out.println("Request intercepted before reaching controller");

        // üîÅ Pass control to next filter or target controller
        chain.doFilter(request, response);

        // ‚úÖ Post-processing logic (after the response comes back)
        System.out.println("Response intercepted after controller processing");
    }
	
	}
	
	when request comes to /api/something. MyFilter intercepts it.
	For a URL: GET /api/users
	console output will be :-
	Request intercepted before reaching controller
	Response intercepted after controller processing
	
	
	Q. what is commandlinerunner - logic executed on every spring boot startup.
	
	@Component
	public class StartupTask implements CommandLineRunner {
    @Override
    public void run(String... args) {
        System.out.println("Run once on startup.");
    }
	}



How Spring Boot supports transaction management?

Spring Boot uses @Transactional to manage transactions.

It supports declarative transaction management via annotations or AOP.

Uses Spring Data JPA or JDBC behind the scenes.

Example:

@Transactional
public void saveData() {
    repository.save(entity);
}
What is a Marker Interface?

An interface with no methods or fields. It is used for metadata or identification purpose. 

Examples: Serializable, Cloneable.

Q  how provide metadata to Spring containers? metadata refers to information provided to the Spring container that tells it:

‚ÄúWhat beans to create, how to wire them, what their lifecycle is, and how they should behave.‚Äù
There are 3 ways to define beans

1. using XML file --application.context
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="myService" class="com.example.MyService"/>
</beans>

2. annotations like @Component, @Service, @Repository, @COntroller are used to mark classes as beans. Spring scans for annotated classes and manages them as beans.
3. using java based configs.

declare beans using @bean

@Configuration
public class AppConfig {

    @Bean
    public MyService myService() {
        return new MyService();
    }
}



Q. How JWT Authentication works?

User logs in ‚Üí server returns JWT token.

Client sends token in Authorization header.

Server validates token (signature + expiry).

On success, allows access to protected resources.

üî® Development Practices
JSP change done, how to push to Bitbucket?

bash
Copy
Edit
git add .
git commit -m "Updated JSP"
git push origin branch-name
Where do you deploy the application after build?

Common servers: Tomcat, WildFly, Jetty, Nginx (reverse proxy).

Cloud: AWS EC2, Elastic Beanstalk, Heroku, GCP App Engine.

Why static methods are not overridden?

They belong to class, not instance.

Method hiding happens, not overriding.

Runtime polymorphism doesn't apply to static methods.

Q. lazy loading in hibernate

@Entity
public class Department{
    
    @OneToMany(mappedBy = "department",fetch = FetchType.LAZY)
    private List<Employee> employees;

   public List<Employee> getEmployees()
   {
	return employees;
   }

}


Session session = sessionFactory.openSession();

session.beginTransaction();


Department dept = session.get(Department.class, 1L);

// At this point, only the department data is fetched.
// No query is executed to load employees yet.

List<Employee> list = dept.getEmployees();

//// Now, when we access getEmployees(), 
// Hibernate executes a separate SQL query to fetch the employees.


for(Employee emp : list)
{
	SOP(emp.getName());
}

session.getTransaction().commit();
session.close();

@Entity
public class Department {

    @OneToMany(mappedBy = "department", fetch = FetchType.EAGER)
    private List<Employee> employees;
}

Session session = sessionFactory.openSession();
session.beginTransaction();


Department dept = session.get(Department.class, 1L);
// At this point, Hibernate executes the following:
// SELECT * FROM Department WHERE id = 1
// AND immediately also:
// SELECT * FROM Employee WHERE department_id = 1

// All data (department + employees) is fetched eagerly upfront.

List<Employee> list = dept.getEmployees();
for (Employee emp : list) {
    System.out.println(emp.getName());
}

session.getTransaction().commit();
session.close();

LazyInitializationException

We try to access a lazy-loaded collection/entity outside of a Hibernate session.

Session session = sessionFactory.openSession();
Employee emp = session.get(Employee.class, id);
session.close();
emp.getDepartment().getName();  //



Helps in performance, avoids heavy joins.

Q.namic vs Static Loading in Java

Static: Classes loaded at compile-time.

Dynamic: Using Class.forName() or reflection at runtime.

Purpose of Generics in Java

Enables type safety, code reuse, eliminates type casting.

List<String> list = new ArrayList<>();
üîó Architecture
Is it microservice architecture if all endpoints are in Spring Boot and Angular is calling them?

No. It‚Äôs monolithic if all endpoints are in one deployable unit.

Microservices = multiple, independent deployables, ideally with separate databases.

How to handle exception in Spring Controller?

Use @ControllerAdvice with @ExceptionHandler:

java
Copy
Edit
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handle(Exception ex) {
        return ResponseEntity.status(500).body(ex.getMessage());
    }
}
JPA vs JDBC Template?

JPA: High-level ORM abstraction (less boilerplate, entity management).

JDBC Template: Manual control, better for complex queries.

Choose JPA for standard CRUD apps, JDBC Template for fine-tuned SQL.

How to deploy WAR in different environments like DEV/SIT?

Configure separate application-dev.yml, application-sit.yml.

Use:

mvn clean package -Dspring.profiles.active=dev
Deploy WAR to environment-specific Tomcat/EC2 server.

If generics are erased at runtime, why use them?

when we compile Java generic code, the type information is erased at runtime. This is known as type erasure.  List<String> list = new ArrayList<>(); at runtime it becomes
List list = new ArrayList();

despite runtime erasure, generics are useful at compile time to catch type errors at compile time.

List<String> list = new ArrayList<>();
list.add("Hello");
// list.add(123); // ‚ùå Compile-time error

String s = list.get(0); // ‚úÖ No casting needed




How is String helpful in memory management?

String Pooling: Common literals reused.

Immutable: Safe for concurrent usage.

Reduces memory footprint by reusing instances.

Q. ch API method for bulk uploads?

@RestController
@RequestMapping("/upload")
public class FileUploadController{
 
 @PostMapping("/multiple")
 public ResponseEntity<String> uploadMultipleFiles(@RequestParam("files") MultipartFile[] files)
{
   for(MultiPartFile file : files)
    {

	can save the file here in DB
    }
	
}

}

Use streaming to process files in memory-efficient way.

üì¶ Testing & Design
Challenges in writing JUnit Tests?

Mocking dependencies (@MockBean, Mockito).

Testing security, JWT-protected endpoints.

DB interaction issues ‚Üí use H2 or TestContainers.

What are Interceptors?

Used to intercept requests/responses.

Common in Spring MVC:

public class MyInterceptor implements HandlerInterceptor {
    public boolean preHandle(...) { ... }
}
Useful for logging, authentication, etc.

How to consume data from one microservice in another?

Use RestTemplate, WebClient, or FeignClient:

@FeignClient(name = "user-service")
public interface UserClient {

    @GetMapping("/api/users/{id}")
    User getUserById(@PathVariable("id") Long id);
}

@RestController
public class OrderController {

    private final UserClient userClient;

    public OrderController(UserClient userClient) {
        this.userClient = userClient;
    }

    @GetMapping("/order/user/{id}")
    public String getUserFromOrderService(@PathVariable Long id) {
        User user = userClient.getUserById(id);
        return "User from Feign: " + user.getName();
    }
}

üí° Java & SQL
What is ConcurrentModificationException?

its a runtime exception which occurs Thrown when modifying a collection while iterating.

List<String> list = new ArrayList<>();
list.add("A"); list.add("B");

for(String item : list)
{
    if(item.equals("A"))
     {
	list.remove(item); its a runtime exception which occurs when a collection is modified while iterating over it.
     }	
}

Avoid by using Iterator.remove() or CopyOnWriteArrayList.

Difference between HAVING and WHERE in SQL

WHERE: Filters before grouping.

HAVING: Filters after GROUP BY.

Difference between Streams and Collections

Collections: Data structure

Streams: Data processing pipeline

Stream is lazy, supports map/filter/reduce.

Return in try block ‚Äì will finally execute?

Yes, finally always executes even if try returns.

try {
    return 1;
} finally {
    System.out.println("Finally runs");
}

System.exit() - immediately terminate the JVM. it will not exeuet the finally block		

Q. various scopes of Beans
1. singleton - only 1 instance of Bean is created per spring container
@Scope("singleton")
2. prototype - A new instance is created every time the bean is requested.
@Scope("prototype")

3. Request/Web only - a new bean is created per HTTP request. Tied to the lifecycle of an HTTP request.
@Scope("request")

4. Session web only - a single bean is per HTTP session. it is tied to user's session
@Scope("session")


Q. SOLID principles
The SOLID principles are five key object-oriented design principles that help make software more understandable, flexible, and maintainable.

// ‚ùå Bad: This class does too many things
class Report {
    void generateReport() {}
    void saveToPDF() {}
    void sendEmail() {}
}

// ‚úÖ Good: Separate responsibilities
class ReportGenerator { void generateReport() {} }
class ReportSaver { void saveToPDF() {} }
class EmailSender { void sendEmail() {} }

2. Open/Closed Principle (OCP)
we should add behaviour to a class without changing existing code. once a class is tested and working, you shouldn't need to modify its source code 
because that risk introduces new bugs.


class NotificationService {
    public void sendNotification(String type, String message) {
        if (type.equals("EMAIL")) {
            System.out.println("Sending EMAIL: " + message);
        } else if (type.equals("SMS")) {
            System.out.println("Sending SMS: " + message);
        }
    }
}


if you want to another notification like push notification that it violates OCP principle.
interface Notification {
   void send(String message);
}

class EmailNotification implements Notification {
    public void send(String message) {
        System.out.println("Sending EMAIL: " + message);
    }
}

class SMSNotification implements Notification {
    public void send(String message) {
        System.out.println("Sending SMS: " + message);
    }
}

Now, if you want to add PushNotification, you just create a new class:

class PushNotification implements Notification {
    public void send(String message) {
        System.out.println("Sending PUSH: " + message);
    }
}


3. Subclasses should behave like their parents.

// ‚úÖ Subclass can replace superclass
class Bird { void fly() {} }

class Sparrow extends Bird { }   // ‚úÖ OK

class Ostrich extends Bird {
    void fly() { throw new UnsupportedOperationException(); } // ‚ùå Violates LSP
}
Fix: Avoid inheritance when behavior differs.

4. Interface Segregation Principle (ISP)
Don‚Äôt force a class to implement methods it doesn‚Äôt use.

// ‚ùå Bad: Fat interface
interface Animal {
    void fly();
    void run();
}

// ‚úÖ Good: Split interfaces
interface Flyable { void fly(); }
interface Runnable { void run(); }

class Dog implements Runnable { public void run() {} }
class Bird implements Flyable, Runnable {
    public void fly() {}
    public void run() {}
}


5. Dependency Inversion Principle (DIP)

// ‚ùå Tight coupling
class MySQLDatabase {
    void connect() {}
}
class UserService {
    MySQLDatabase db = new MySQLDatabase();
}

// ‚úÖ DIP using interface
interface Database {
    void connect();
}

class MySQLDatabase implements Database {
    public void connect() {}
}

class UserService {
    private final Database db;
    public UserService(Database db) {
        this.db = db;
    }
}

Q. what are synchronized maps
Map<K, V> originalMap = new HashMap<>();
Map<K, V> syncMap = Collections.synchronizedMap(originalMap);

// A synchronized map ensures thread-safe access to a Map, meaning only one thread can access it at a time.

in synchronized maps - 1 null key and multiple null values are allowed. while in ConcurrentHashMap its not allowed.
concurrent hashmap allows multiple threads to access and modification
performance wise concurrent hash maps are faster due to concurrent access.

Q. how to make a collection as thread safe

use synchronized 

List<String> list = Collections.synchronizedList(new ArrayList<>());
Set<String> set = Collections.synchronizedSet(new HashSet<>());
Map<String, String> map = Collections.synchronizedMap(new HashMap<>());


Q. What Happens If You Don't Override equals() and hashCode() in HashMap
it will lead to duplicate stores. incorrect bucket access, and can return null while retrieving values.



Q. in case of POST mappings, how to retrieve data into code. 
Use the following annotations:

@RequestBody ‚Üí for JSON/form body payload.

@RequestParam ‚Üí for query parameters.

@PathVariable ‚Üí for URL path parameters.

java
Copy
Edit
@PostMapping("/user/{id}")
public ResponseEntity<String> createUser(
        @PathVariable Long id,
        @RequestParam String type,
        @RequestBody UserDto userDto) {
    // logic
}


Q. For GET requests, what annotation is used to retrieve data into code?

@RequestParam ‚Üí for query string: ?name=John

@PathVariable ‚Üí for path: /user/{id}

@GetMapping("/user/{id}")
public User getUser(@PathVariable Long id, @RequestParam(required=false) String type)
{

}

Q. 3. What are different bean scopes in Spring? When to use which?
Scope	Description	When to Use
singleton	One shared instance per spring container. when bean dont hold session specific data. shared across the app
prototype	New instance is created everytime its requested.  when each user//task needs a fresh object
request	One bean per http request. when data is required only during lifecyccyle of http request
session	One per HTTP session	Session-scoped beans. one bean per user session, to store user specific data l


Q. have you written any unit test using JUnit and Mockito ?
Mocking dependencies using @Mock or Mockito.mock().

Using @InjectMocks to inject into the class under test.

Challenges faced:

Handling NullPointerException when mocks aren't set up properly.

1. ensure using @InjectMocks for the class you are testing.
	@InjectMocks
	priate UserService userService;

2. ensure mocks are initialized using @ExtendWith(MockitoExtension.class)

@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    // mocks and test
}


Q. If a Set has duplicate custom objects (not primitives), will it remove them?
Only if equals() and hashCode() are properly overridden, it will consider both the objects are same and duplicate will be removed.
else it will consider them as different.

ex
	Set<Persont = new HashSet<>();
        set.add(new Person("Alice", 25));
        set.add(new Person("Bob", 30));
        set.add(new Person("Alice", 25)); // duplicate

        System.out.println("Set size: " + set.size());
        System.out.println("Set content: " + set);

@Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Person)) return false;
        Person p = (Person) o;
        return age == p.age && Objects.equals(name, p.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }

Q. Can HashMap have duplicate keys or values?
key cant be duplicate. only values can be duplicated

Q. example of static headers. in any application, we have 20  rest controllers and in response header will have static headers. how will you avoid to touch all the controllers and servce specific controllers.

 static headers (like X-App-Version, X-Correlation-ID, Cache-Control, etc.) that need to be added to every HTTP response, and you want to avoid modifying each of your 20+ controllers, the best solution is to use a Spring Filter or Interceptor.

@Component
public class StaticHeaderFilter implements Filter{

    @Override
    public void doFIlter(ServletRequest request, ServletResponse response,
                         FilterChain chain) throws IOException, ServletException
    {
	
	HttpServletResponse httpServletResponse = (HttpServletResponse) response;

        httpServletResponse.setHeader("X-App-Version", "1.0");
        httpServletResponse.setHeader("X-Powered-By", "Spring Boot");
        httpServletResponse.setHeader("Cache-Control", "no-cache");

        chain.doFilter(request, response); // Pass control to controller

    }

}

@RestController
@RequestMapping("/api")
public class HelloController {

    @GetMapping("/hello")
    public ResponseEntity<String> sayHello() {
        return ResponseEntity.ok("Hello from Spring Boot");
    }
}


GET http://localhost:8080/api/hello

HTTP response

HTTP/1.1 200 OK
Content-Type: text/plain
X-App-Version: 1.0
X-Powered-By: Spring Boot
Cache-Control: no-cache
Content-Length: 24
Date: Mon, 08 Jul 2025 10:30:00 GMT

Hello from Spring Boot



Q. What happens if value is immutable in HashMap?

An immutable object (like String, Integer, etc.) cannot be modified once created.

String str = "abc";
str.toUpperCase(); // returns a new String, doesn't modify "abc"

Map<String, String> map = new HashMap<>();
map.put("key1", "abc");  // "abc" is an immutable String

// Now:
String value = map.get("key1"); // value = "abc"
value.toUpperCase();           // returns "ABC", but "abc" is not changed in map

System.out.println(map.get("key1"));  // still prints "abc"

Q. difference between hibernate and JPA
Hibernate is a JPA implementation, but it adds powerful features that JPA doesn‚Äôt define. 
It provides operations for CRUD.. save(), update(), delete(). caching to avoid hitting the DB repeatedly. Lazy Loading (@Lazy)

1. Create

Session session = sessionFactory.openSession();
session.beginTransaction();

User user = new User();
user.setName("John");
session.save(user);

session.getTransaction().commit();
session.close();
2. Read

User user = session.get(User.class, 1L); // or session.load()

3. Update
user.setName("Jane");
session.update(user);


4. Delete
session.delete(user);

JPA is a specification or blueprint. hibernate is implementation. JPA does not provide any implementation.part of Jakarta EE
JPA helps in mapping java classes to DB tables and perform CRUD operations. to actually use JPA, we need an implementation like Hibernate. 
examples - @Entity, @Table, @Id, @OneToOne / @OneToMany / @ManyToOne	Relationships between entities


Q. API1 expects 1 input, API2 expects 2 inputs. How to write logic?

@RestController
public class APIController{

   @GetMapping("/api")
    public ResponseEntity<?> handleApi(@RequestParam(required = false) String id1,
                                       @RequestParam(required = false) String id2) {
        if (id2 == null) {
            return singleIdLogic(id1);
        } else {
            return twoIdLogic(id1, id2);
        }
    }
    
    private ResponseEntity<?> singleIdLogic(String id1) {
        if (id1 == null || id1.isBlank()) {
            return ResponseEntity.badRequest().body("Missing required parameter: id1");
        }

        // Simulate business logic for API1
        String message = "API1 processed with id1 = " + id1;
        return ResponseEntity.ok(message);
    }

    // Handles logic when both id1 and id2 are provided
    private ResponseEntity<?> twoIdLogic(String id1, String id2) {
        if (id1 == null || id1.isBlank() || id2 == null || id2.isBlank()) {
            return ResponseEntity.badRequest().body("Both id1 and id2 are required for API2");
        }

        // Simulate business logic for API2
        String message = "API2 processed with id1 = " + id1 + ", id2 = " + id2;
        return ResponseEntity.ok(message);
    }


}


Q. If an exception occurs in DAO, how to cascade it to UI?
Throw custom exceptions and use @ControllerAdvice for global exception handling.

Q. challenge failed during deployment
App failed to start due to port already in use. Changed port in application.properties or killed conflicting process

1. environment config issues
a) application works locally fails on staging production
   cause is missing incorrect variables like DB urls, credentials ports
Spring Boot app fails to start because application-prod.properties is misconfigured.

b) dependency mismatch
  app crashes with classnotfoundexception App built with Java 17 but deployed on server with Java 11.

c) port confilicts
Another process is already running on the desired port (e.g., 8080).Stop conflicting process or change app port in application.properties

Q. database not connecting
added driver dependency mysql-connector-java).

Updated application.properties with correct credentials and URL.
	
Q. Challenges While Creating APIs
1.equestBody mapped to a null object.. DTO fields were missing setters or improper JSON sent.

2, hitting users with POST worked but with GET it didn't worked.

Fix: Ensured correct @GetMapping, @PostMapping, etc. with matching URLs.

2 Pagination/Sorting Not Working
API returned all records, no pagination.


Pagination is used to return a subset of data rather than the entire result set. This improves performance, especially for large tables or APIs returning lists.

@GetMapping
public Page<User> getAllUsers(
    @RequestParam(defaultValue = "0") int page,
    @RequestParam(defaultValue = "5") int size,
    @RequestParam(defaultValue = "id") String sortBy
)

{
        Pageable pageable = PageRequest.of(page, size, Sort.by(sortBy));
        return userRepository.findAll(pageable);
}

page is page number to fetch ex 0 is first page. size is number of records to fetch per page
sortBy is sort the results by name, email


Q. real use of singleton and prototype scope



Q. interface has 2 subclasses and a third class autowires the interface. what happens

interface Vehicle {}
@Component class Car implements Vehicle {}
@Component class Bike implements Vehicle {}
@Component class TransportService {
    @Autowired
    private Vehicle vehicle;
}

spring throws NoUniqueBeanDefinitionException, because it doesn't know to inject Car or Bike

1. 
@Autowired
@Qualifier("car") // or "bike"
private Vehicle vehicle;

2. @Primary
   @Component
   class Car implements Vehicle {}

Q. difference between singleton scope and prototype scope
one instance for entire application is created per spring container.

Is shared across the application (singleton).

package com.example.logging;

import org.springframework.stereotype.Component;

@Component  // Default scope is singleton
public class LoggerService {

    public void logInfo(String message) {
        System.out.println("[INFO] " + message);
    }

    public void logError(String message) {
        System.err.println("[ERROR] " + message);
    }
}

Q. what is @Prototype Bean scope example
@Component
@Scope("prototype")
public class Invoice {
    private final String invoiceId;

    public Invoice() {
        this.invoiceId = UUID.randomUUID().toString();
        System.out.println("Created Invoice: " + invoiceId);
    }

    public String getInvoiceId() {
        return invoiceId;
    }
}

@Service
public class OrderService {

    @Autowired
    private ObjectFactory<Invoice> invoiceFactory;

    public void placeOrder(String customerName) {
        Invoice invoice = invoiceFactory.getObject(); // Fresh instance will be created everytime
        System.out.println("Placing order for " + customerName + " with invoice " + invoice.getInvoiceId());
    }
}

Each time a customer places an order, you want to generate a new Invoice object ‚Äî independent from other requests.

Q. Function<T, R>  Tkes one argument of type T and returns a result of type R

Function<String, Integer> strLength = str -> str.length();
System.out.println(strLength.apply("hello"));


2. Predicate<T>

Predicate<Integer> isEven = num -> num % 2 == 0;
System.out.println(isEven.test(4));

3. Consumer<T> Takes one argument and returns nothing (void).

Consumer<String> greet = name -> System.out.println("Hello, " + name);
greet.accept("rachit");

4. BiFunction<T, U, R>

BiFunction <Integer, Integer, Integer> sum = (a, b) -> a + b;

System.out.prinln(sum.apply(10, 20));

5. BiPredicate<T, U> 	takes two arguments and returns Boolean

BiPredicate<String, Integer> isLengthEqual = (str, len) -> str.length() == len;

SOP(isLengthEqual.test("hello", 5));

6. Consumer<String> greet = name -> System.out.println("Hello, " + name);
	greet.accept("rachit");

7. it takes 2 arguements nd returns boolean
  BiPredicate<String, Integer> isLengthEqual = (str, len) -> str.length() == len;
   
   SOP(isLengthEqual.test("hello", 5));


8. what is DB connection pool
A Database Connection Pool is a cache of database connections maintained so that connections can be reused when future requests to the database are required.

Instead of creating a new DB connection for every request (which is slow and expensive), a pool reuses pre-created connections.

9. sortedDistinctMarks
List<Integer> sortedDistinctMarks = students.stream()
    .map(Student::getMarks)
    .distinct()
    .sorted(Comparator.reverseOrder())
    .collect(Collectors.toList());




10.ACID properies 
Atomicity --    All operations succeed or none do.
Consistency	DB moves from one valid state to another.
Isolation	Concurrent transactions don't interfere.
Durability	Once committed, the result is permanent.

START TRANSACTION;

UPDATE accounts SET balance = balance - 1000 WHERE account_id = 'A';

UPDATE accounts SET balance = balance + 1000 WHERE account_id = 'B';

COMMIT;

Atomicity: Both debit and credit must happen. If credit fails, debit is rolled back.

Consistency: The total amount in the system (A+B) remains the same before and after.

Isolation: If another transaction checks Account A while the transfer is halfway, it should not see the intermediate state.

Durability: Once the transfer is committed, it remains saved even after a system crash.

Q. what are hibernate caching levels

1. first level - enabled by default. per session cache, Same entity retrieved multiple times in the same session 
2. second level - optional, must be enabled explicitly
3. query cache - caches the results of queries.



public class SecondHighestSalary {
    public static void main(String[] args) {
        List<Integer> salaries = Arrays.asList(5000, 7000, 6000, 7000, 8000, 8000, 9000);

        int secondHighest = salaries.stream()
            .distinct() // remove duplicates
            .sorted(Comparator.reverseOrder()) // sort descending
            .skip(1) // skip highest
            .findFirst().get(); // get second highest

        System.out.println("Second highest salary: " + sal);
    }
}


SELECT MAX(salary) AS SecondHighestSalary
FROM employees
WHERE salary < (
    SELECT MAX(salary) FROM employees
);


Q. @SpringBootApplication = combines @Configuraion,@EnableAutoConfiguration, @ComponentScan

it reduces the boiler plate code by bundling 3 annotations into 1,simplifies spring configuration. enabled auto confg of Spring boot

package com.example.demo.service;

@Component
public class MyService{
    
	public String getMessage()
	{
	   return "Hello from MyServicce";
	}	
}



@Configuration
@ComponentScan("com.example.demo.servce")
public class AppConfig{

}


class MainApp{

   psvm()
   {
	ApplicationContext context = new ApplicationContext(MainApp.class);

	MyService service = context.getBean(MyService.class);
	service.getMessage();    Hello from MyServicce
   }

}


Q. use of @Bean

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate() {
        // Custom configuration before returning
        return new RestTemplate();
    }
}

Anywhere you @Autowired a RestTemplate, you‚Äôll get this instance.The method‚Äôs return value will be registered as a bean in the Spring ApplicationContext.

Q. Immutable classes in Java and How do we implement one?

declare class as final, make all fields as private and final, no setter methods. 

final class Employee {
    private final String name;
    private final int id;

    public Employee(String name, int id) {
        this.name = name;
        this.id = id;
    }

    public String getName() { return name; }
    public int getId() { return id; }
}

Q. How does immutability help in multithreading?
Immutable objects are thread-safe by nature since their state cannot change. Multiple threads can access them without synchronization.

Q. Purpose of serialization in a POJO and common use cases
Serialization converts a Java object into a byte stream for:

Sending over network (distributed systems)

Saving to disk (persistence)

Caching

Q. challenges while sending java object over network.

Compatibility (Java version, class changes)

Performance

Security (exposure of internal structure)


Q. what is singleton patterns in java

public class Singleton{
	
    private static Singleton instance = new Singleton();

    private Singleton()
    {

    }

    public static Singleton getInstance()
    {
       return instance;
    }
}

Q. How to make Singleton thread-safe?

public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null)
                    instance = new Singleton();
            }
        }
        return instance;
    }
}

Q. Override equals but not hashCode ‚Äî what happens?
then objects may be equal but stored in different buckets in a hashmap. causing unexpected beheviour like duplicates

Q.Handle global exceptions in Spring Boot

@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleAll(Exception e) {
        return new ResponseEntity<>("Error: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }
}


Q. Two beans of same type, no @Qualifier ‚Äî what happens?
Spring throws NoUniqueBeanDefinitionException


Q. ckt breaker pattern

@CircuitBreaker(name = "backendService", fallbackMethod = "fallback")
public String fetchData()
{
	return restTemplate.getForObject("http://some-api", String.class);

	// if above API fails due to any exception like timeout , 500 error than fallbackMethod will be called
}

public String fallback(Throwable t)
{
   return "fallback response";
}

Q. SQL query to count duplicates in a column

select column_name, count(*)
from table_name
group by column_name
having count(*) > 1;


Q what are paralle streams.Java 8 introduced the Stream API, which allows you to process collections in a functional way.
Normally, .stream() processes elements sequentially (one thread).
.parallelStream() (or stream().parallel()) splits the work into multiple threads

List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);

// Sequential
list.stream()
    .forEach(System.out::println);

// Parallel
list.parallelStream()
    .forEach(System.out::println); // Order not guaranteed

Q. what is BeanInitialization exception

A runtime exception thrown when Spring fails to create or initialize a bean during the application context startup.

Missing dependencies (@Autowired fails due to no matching bean found).
Circular dependencies (Bean A needs Bean B, which also depends on Bean A).

Q. how to resolve circular dependencies.

use @Lazy, spring will delay creating the bean until its really required.

@Component
class A {
    @Autowired
    @Lazy
    private B b;
}

@Component
class B {
    @Autowired
    @Lazy
    private A a;
}

Q. Can Constructors be Synchronized?
Yes, you can declare a constructor as synchronized, but it has no practical effect in the way you might think.
The synchronized keyword on a constructor locks the object being constructed.

public class MyClass {
    public synchronized MyClass() {
        System.out.println("Constructor is synchronized");
    }
}


Q. returning both HTML views and JSON response from a single controller

@Controller
@RequestMapping("/products")
public class ProductController {

    // Returns HTML view
    @GetMapping("/view")
    public String showProductPage(Model model) {
        model.addAttribute("name", "Laptop");
        return "productView"; // maps to productView.html
    }

    // Returns JSON response
    @GetMapping("/json")
    @ResponseBody
    public Product getProductJson() {
        return new Product(1, "Laptop", 1200);
    }
}


Q. Can a @Controller return String or JSON? How?

String ‚Üí Yes, by default, it's treated as the view name.


use @ResponseBody on the method

Q. use of @Autowired annotation

<beans>
    <bean id="orderService" class="com.example.OrderService" />
    <bean id="paymentService" class="com.example.PaymentService" />
</beans>

@Component
public class OrderService{
	
   @Autowired
   private PaymentService service;
	
}



Q. diff between PUT and PATCH 
PUT will do full update of resource while PATCH does partial update

Q. Design patten used in IOC is Dependency injection pattern

Q. things to consider while creating API's
1. http methods are correct - GET, POST, DELETE
2. Input validation to avoid bad data
3. use pagination, caching
4. use authentication and authorization

Q. how to secure API's
verify who is the User - jwt, Oauth2, API keys
do input sanitization
HTTPS - always encrypr traffic


@PreAuthorize("hasAuthority('USER_READ')")
public List<User> getAllUsers() {
 return userService.findAll();
}


If the logged-in user doesn‚Äôt have USER_READ authority, they‚Äôll get a 403 Forbidden ‚Äî instantly. No business logic is executed.

hasAuthority() vs hasRole()
 * hasAuthority('ADMIN') checks for exact authority
 * hasRole('ADMIN') checks for authority with ROLE_ prefix (e.g. ROLE_ADMIN)


Q. points to consider while mpving from monolithic to microservice arch

split the services accordingly
each MC should have its own DB
inter service comm - REST, gPRC, messaging - kafka/RabbitMQ
API G/W - central point for routing  requests to diff micro services
service discovery use Eukera server
deply strategy using CI/CD pipelines, containers Kubernetes


Q. @OneToMany annotation

1 dept multiple employees

@Entity{
public class Department{ 
  
   @Id
   @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

  @OneToMany(mappedBy = "department", cascade = CascadeType.ALL)
  private List<Employee> employees = new ArrayList<>();
	
   any operation you perform on parent entity wil also be performed on child entity.

CascadeType.ALL is a shortcut for enabling all of these:

PERSIST ‚Äì Save the child entity when you save the parent.

MERGE ‚Äì Update the child entity when you update the parent.

REMOVE ‚Äì Delete the child entity when you delete the parent.

REFRESH ‚Äì Refresh child entity when you refresh the parent from DB.

DETACH ‚Äì Detach child entity from persistence context when parent is detached.

}	

    
@Entity
public class Employee{
  
   @Id
   private Long id;

   @ManyToOne
   private Department department;

}


@Entity
public class Student{

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToMany(cascase = CascadeType.ALL)
    private Set<Course> courses = new HashSet<>();

}


Q. explain normalization - process to remove redundancy and ensure data integrity by organizaing data into separate tables.
various normal forms are like 1NF, 2NF, 2NF

Q. indexes help in speeding up retrieval by providing quick lookups

ex select * from employee where empId = 5; so do indexing on empId;


Q. ArrayList Ordering

ArrayList maintains insertion order, NOT sorted order.

If you want sorted data, you must use Collections.sort(list) or TreeSet/PriorityQueue.


Q. JVM divides memory into three main runtime areas:

Heap ‚Üí Stores objects and their instance variables.

Stack ‚Üí Stores method call frames, local variables, references.

Method Area (a.k.a. MetaSpace in Java 8+) ‚Üí Stores class metadata, static variables, static methods, and constant pool.


Q. wht are caching levels in hibernate ?

1. first level
Session session = sessionFactory.openSession();
Employee emp1 = session.get(Employee.class, 1);

here scope is per session, keep entity in memory in same hibernate session

2. 2nd level
Across multiple sessions, shared at the SessionFactory level.
@Cacheable

3. Query cache

List<Employee> employees = session.createQuery("from Employee").setCacheable(true).list();


abstract class A {
    A() {
        System.out.println("A");
    }
}

class B extends A {
    B() {
        System.out.println("B");
    }
}

output of

A a1 = new A();  
A a2 = new B();  
B b1 = new A();  
B b2 = new B(); 

A a1 = new A();  B b1 = new A();  error, object of abstract class cant be created. 


first parent class constructor will be called the of child class

A
B
A
B

Q. int getNumber() {
    try {
        int x = 10 / 0;   // this will throw ArithmeticException
        return 3;
    }
    catch(Throwable t) {
        return 5;
    }
    finally {
        return 7;
    }
}

if exception occurs or not, answer will always be 7

Q. output of below code

class A{
    
    public void getName(){
        System.out.println("A");
    }
    
}

class B extends A{
    
    public void getName(){
        System.out.println("B");
    }
    
}


class Main {
    public static void main(String[] args) {
        
        A a1 = new A();
        A a2 = new B();
        B b1 = new A();
        B b2 = new B();
        
        a1.getName();  A
        a2.getName();  B
        b1.getName();  //error A cannot be converted to B
        b2.getName();  B
        
    }
}

if getName() method is made as static in classA then program wont run as overridden method is static.. Need to make static in child class also


Q. Constructor calling in java

class Parent{
	
     Parent(String msg)
    {
	System.out.println("parent constructor " + msg);
    }
}

class Child extends Parent{
	
     Child()
     {
	super("hello");
        SOP("child constructor");
     }
}

public class Test{
  

   psvm()
   {
	Child c = new Child();      parent constructor hello
				    child constructor

    }

}

Q> how to design API gateways -> using Spring cloud

Q. find top 3 earning employees

select distinct salary from Employee order by salary desc limit 3;

Q. flatMap example in stream API

List<List<String>> namesNested = Arrays.asList(
                Arrays.asList("Rachit", "Mohit"),
                Arrays.asList("Amit", "Sumit"),
                Arrays.asList("Raj")
        );

        // Flatten list of lists into a single list
        List<String> namesFlat = namesNested.stream()
                .flatMap(List::stream)
                .collect(Collectors.toList());

        System.out.println(namesFlat); 


Q. challenges in MC architecture

1.Service Discovery & Communication
Managing how services find and talk to each other

2. Data Management
Each service may have its own database ‚Üí handling distributed transactions, data consistency, and reporting is complex.

3 Security
Securing internal service-to-service communication (authentication, authorization

4. monitoring - with small services, centralized logging tracing metrics collection using Prometheus, grfana is crucial.
5. unit testing is easy but integration testing and E2E testing is difficult

Q. how to ensure data consistency in microservices
SAGA pattern - A Saga is a sequence of local transactions across services. If one transaction fails, compensating transactions are executed to roll back previous steps.

Example:

Order Service creates order ‚Üí emits OrderCreated.

Payment Service reserves money ‚Üí emits PaymentSuccessful.

Inventory Service reserves items ‚Üí emits StockReserved.

If step 3 fails ‚Üí send PaymentRollback.

Event-Driven Architecture (EDA) - Services communicate via events (Kafka, RabbitMQ). Ensures data consistency by event propagation.



Q. how to secure comm in MC's

use API gateway, JWT token to validate user services access
data protection encrypt data using https


Q. Idempotency in APIs.an operation which can be called multiple times with the same input and will always 
produce the same result without additional side effects. 

GET /users/1 ‚Üí Safe and idempotent.

PUT /users/1 (update user) ‚Üí Idempotent.

POST /users (create user) ‚Üí Not idempotent. eveytime adds a new resource.


Q. how to do Database performance tuning

1. use indexing in columns in frequent queries but dont overuse index as it can take extra storage space.

2. normalization - Organizing data in a relational database into multiple related tables to reduce redundancy and ensure data consistency.
helps in avoiding duplication.

3. Partitioning / Sharding for large datasets
Splitting a single large table into smaller partitions based on a key (like date, region, or ID range) while still in the same database.

Horizontal partitioning (row-based): e.g., Orders_2023, Orders_2024.

Vertical partitioning (column-based): split wide tables into smaller ones by grouping columns.

Sharding - Distributing data across multiple database servers. (different physical machines).

Each shard is responsible for a subset of data (e.g., users A‚ÄìM on Shard 1, users N‚ÄìZ on Shard 2).


Q. Scaling Microservices

Horizontal scaling: Add more instances of service (stateless services + load balancer). Preferred.

Vertical scaling: Add more CPU/RAM to one server. Limited scalability.


Q. how to Handle huge number of requests

Use Load Balancer (NGINX, AWS ALB).

Horizontal scaling with stateless services.

Use Message Queues (Kafka, RabbitMQ).

Caching (Redis).

Backpressure / Rate Limiting.

Q. Debugging & Production Issues

Use logs (structured logging ‚Üí ELK stack, Splunk).

Metrics / Monitoring (Prometheus + Grafana, Micrometer).

Feature flags to disable problem features.

Rollback deployment if needed.


Q. Application performance optimization strategies

Opening a new connection = expensive (handshake, authentication, network round trip)
Reduce synchronous DB calls ‚Üí use caching,
Use DB connection pool
Instead of creating a new connection every time, the application borrows a connection from the pool.

When finished, it returns it to the pool instead of closing it. Next request can reuse the same connection.

spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=secret

# Connection pool settings
spring.datasource.hikari.maximum-pool-size=20   # max connections
spring.datasource.hikari.minimum-idle=5         # idle connections ready
spring.datasource.hikari.idle-timeout=300000    # 5 mins before closing idle
spring.datasource.hikari.max-lifetime=1800000   # 30 mins per connection




Q. Kafka vs RabbitMQ

Kafka:

Distributed event streaming platform.

High throughput, persistent, replayable messages.

Good for event-driven architectures, log aggregation.

RabbitMQ:

Traditional message broker.

Complex routing (topics, fanout, direct).

Good for task queues and request/response.

Q. Monitoring logs in production Spring Boot apps

Use Centralized Logging: ELK Stack (Elasticsearch, Logstash, Kibana), EFK (Fluentd), Splunk.

Add structured JSON logging (logback-spring.xml).

Use Spring Boot Actuator for health/metrics.

Tools: Prometheus + Grafana for metrics, Zipkin/Jaeger for tracing.

Q. What are Spring Boot Starter Dependencies?
A Starter Dependency in Spring Boot is a predefined set of commonly used dependencies bundled together in a single POM dependency.

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
‚úÖ That one line brings Spring MVC, Jackson (JSON), Tomcat, and other dependencies.
Spring Boot automatically brings the right versions.



@EnableAutoConfiguration checks the dependencies and autoconfigures the usefulbeans into our application.
for ex if above starter web is included in pom.xml, @EnableAutoConfiguration auto configures tomcat server, dispatcher servlet, datasource if driver is present.

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

if above dependency is present, @EnableAutoConfiguration automatically adds below dependencies in the application

like spring data jpa, hibernate-core, spring-tx. It activates EntityManagerFactory, repositories interface like JPARepository, CrudRepository etc




Q. what is async
In many apps, sending an email or generating a PDF report is time-consuming.
If you make it synchronous, the user has to wait until the task finishes.
With @Async, the request immediately returns a response, and the heavy task runs in the background.


import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

@Service
public class NotificationService {

    @Async   // üî• executes in a separate thread (non-blocking)
    public void sendEmail(String userEmail) {
        try {
            System.out.println("Sending email to " + userEmail +
                    " in thread: " + Thread.currentThread().getName());
            Thread.sleep(5000); // simulate delay
            System.out.println("Email sent successfully to " + userEmail);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}


import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class NotificationController {

    private final NotificationService notificationService;

    public NotificationController(NotificationService notificationService) {
        this.notificationService = notificationService;
    }

    @GetMapping("/notify")
    public String notifyUser() {
        notificationService.sendEmail("user@example.com"); // async call
        return "Request received! Email will be sent in background.";
    }
}

User calls http://localhost:8080/notify.
console logs

Sending email to user@example.com in thread: task-1
Request received! Email will be sent in background.
Email sent successfully to user@example.com


Q. what are web client in asynchronous communucation in microservices

RestTemplate is used for synchronous communication.WebClient is part of Spring WebFlux asynchroinous communication (introduced in Spring 5).

It‚Äôs a non-blocking, reactive web client used to make HTTP calls between microservices.

Unlike RestTemplate (which waits until the response arrives), WebClient returns immediately with a reactive type (Mono or Flux) and handles the response asynchronously.when one service depends on others, but you don‚Äôt want to block execution until they reply.

@Service
public class OrderService{

    private final CustomerClient customerClient;

    public OrderService(CustomerClient customerClient) {
        this.customerClient = customerClient;
    }

    public Mono<String> placeOrder(String customerId)
    {
	 return customerClient.getCustomerById(customerId)
                .map(customer -> "Order placed for: " + customer.getName());

    }

}


@Service
public class CustomerClient{

     private final WebClient webClient;
    
    public CustomerClient(WebClient.Builder builder) {
        this.webClient = builder.baseUrl("http://customer-service").build();
    }

    public Mono<Customer> getCustomerById(String id)
   {
	return webClient.get()
               .uri("/customers/{id}", customerId)
               .retrieve()
               .bodyToMono(Customer.class)
               .timeout(Duration.ofSeconds(3)) // if no response in 3s ‚Üí error
            .onErrorResume(e -> {
                System.out.println("Error occurred: " + e.getMessage());
                return Mono.empty(); // return empty instead of failing
.            });
   }

}

Once the remote service replies, the data is pushed into the Mono, and downstream operators (map, flatMap, etc.) get executed.
The Mono completes with an error signal (e.g., WebClientResponseException, TimeoutException).


Q. Daemon threads
They are low-priority threads that run in the background (e.g., garbage collection, monitoring tasks).Any thread can be marked as a daemon thread using:
thread.setDaemon(true);



Q. what is websocket, STOMP ?
websocket is a 2 way messaging protocol both client and server can send msg to each other. full duplex, real time 
STOMP - simple text oriented msg protocol. has a publish a subscribe model.
server pushes data to a topic, client will subcribe to the topic and get the data from those topics


Q. 
Integer c = 200;
Integer d = 200;
System.out.println(c == d);

Output will be false, because 200 is outside the cache range, so two different objects are created.
The JVM maintains a cache of Integer objects in the range -128 to 127.

Integer c = 20;
Integer d = 20;
System.out.println(c == d);
outpt will be true, So both c and d point to the same cached object when the value is within that range.


Q. String a = "hello";              // goes into String pool
String b = "hel" + "lo";         // compile-time constant ‚Üí "hello" from pool
String c = "hel";                // from pool
String d = c + "lo";             // runtime concatenation ‚Üí new String object. This creates a new String object on the heap

a == b, output is true. Both a and b point to the same "hello" in the String pool.

a == d - false

a.equals(d) -> true


Q. find 2nd highest salary dept wise

select e1.name, e1.department, max(e1.salary)
	from Employee e1
	where e1.salary < (select max(e2.salary) from Employee e2	
	where e2.department = e1.department
); 



Q. what is AOP. A programming paradigm to separate cross-cutting concerns (like logging, security, transactions) from business logic.

pointcut - A predicate (expression) that selects specific join points..it defines where advice should run
join point - A point during execution of a program where an Aspect can be applied. ex - Method execution, Exception thrown

public class PaymentService {
    public void processPayment() {
        System.out.println("Processing payment...");
    }
}

@Aspect
public class LoggingAspect{
	
  //// Pointcut: execution of any method in PaymentService class

  @Pointcut("execution((* com.example.service.PaymentService.*(..))")
  public void paymentServiceMethods() {}
  
  //  // Advice: runs before the join point
  @Before("paymentServiceMethods()")
  public void logBefore()
  {
     SOP("logging before the method execution");
  }

}

Join Point - The actual method execution processPayment()
Pointcut - execution(* com.example.service.PaymentService.*(..)) (selects all methods in PaymentService).
advice - action you want to run logging. logBefore


Q. what are spring dev tools
Spring Boot DevTools is a set of tools that improve the developer experience during development by providing features that make coding, testing, and debugging faster and easier.


1Ô∏è‚É£ Automatic Restart:

Automatically restarts the application whenever files on the classpath change (e.g., code or resources).

Speeds up development because you don‚Äôt need to manually restart the app.

2Ô∏è‚É£ LiveReload Support:

Automatically refreshes the browser when resources (like HTML, CSS, JS) change.

Useful when working on web applications.


Add dependency in pom.xml

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <optional>true</optional>
</dependency>


Q. What is DispatcherServlet in Spring MVC?
DispatcherServlet is the front controller in Spring MVC.

It handles all HTTP requests, delegates them to appropriate controllers, and manages the entire request-response lifecycle.

‚úÖ Typical flow:

Request ‚Üí DispatcherServlet.

DispatcherServlet finds the appropriate Controller.

Controller processes the request and returns a ModelAndView.

DispatcherServlet resolves view and returns response.


@RestController
public class UserController{

	
  @GetMapping("/users")
  public List<String> getUsers()
  {
     return List.of("jana", "kamal");
  }
}

when /users is accessed, dispatcher servlet intercepts the request
delagates it to getUsers() method in UserController and returns the list of users in JSON


Q. what is service oriented architecture, diff between SOA and microservices.

SOA is an architectural style where applications are composed of loosely coupled services that communicate over a network. 1 service can perform multiple functionalities.

communication is via SOAP, often share DB.

services are deployed together on the same servers, harder to scale independently.

Microservices - fine grained, focus on 1 functionality.
communicated via REST, HTTP.

each MS has its own DB, independent deployable service. easier to scale individual microservice

Q. how to prevent SQL injection ?

Use PreparedStatement instead of Statement.

String query = "SELECT * FROM users WHERE username = ? AND password = ?";
PreparedStatement pstmt = connection.prepareStatement(query);
pstmt.setString(1, username);
pstmt.setString(2, password);
ResultSet rs = pstmt.executeQuery();

Q. Does Not Overriding hashCode() Impact Performance?

If you override equals() but not hashCode(), different objects that are logically equal may not hash to the same bucket ‚Üí leads to poor performance in retrieval.


Q. there is a server having large amount of data. its taking lots of time to respond, how to resolve this issue wrt java, issue is with server side

1. Instead of returning the entire dataset in one response, return data in small chunks (pages).

Pageable pageable = Pagerequest.of(pageNumber, pageSize);
Page<Employee> page = pageRepo.findAll(pageable);

List<Employee> employees = page.getContent();

Reduces memory load.

Improves response time.

Supports lazy loading of data.

or use Stream API's. If data needs to be processed sequentially without loading all into memory:


2. Optimize DB queries.

Avoid SELECT *; select only necessary columns.

Add indexes on frequently filtered columns.

3. Asynchronous Processing

use executorservice, to Offload long-running tasks to background threads (e.g., using ExecutorService) and return response immediately.

ExecutorService executor = Executors.newFixedThreadPool(10);
executor.submit(() -> processLargeData());

4. use @Cacheable


Q. what is Multipart file ?

it is used for uploading files - images, documents through web forms to a server.
it allows multiple part or files to be uploaded in a single HTTP request.

@RestController
public class MultiFileUploadController {

   @PostMapping("/uploadMultiple")
   public String uploadMultipleFiles(@RequestParam("files") Multipart[] files)
   {

	for(MultipartFile file: files)
         {
		String filename = file.getOriginalFilename();
                 long size = file.getSize();

		try{

			file.transferTo(new File("uploads/" + fileName));
		}
		catch(Exception e)
		{
			return "Error uploading file: " + fileName;
		}		
         }
	
   }

}


Q.What is the role of SpringApplication.run() and what happens internally?

1. Entry point to start a Spring Boot application
2. Loads configuration properties from application.properties, YAML files.
3. Create ApplicationContext
4. Spring Boot automatically configures beans based on classpath and properties.
5.Starts embedded Tomcat/Jetty/Undertow server.

Q How do you disable a specific auto-configuration?

When the application starts, Spring Boot looks for the file: META-INF/spring.factories
In this file, it reads the key:

org.springframework.boot.autoconfigure.EnableAutoConfiguration

he value of this key is a comma-separated list of configuration classes, for example:

org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration


Spring Boot loads all these configuration classes i the application.If you have spring-boot-starter-data-jpa in your classpath:

Spring Boot finds HibernateJpaAutoConfiguration from spring.factories.. If found, it auto-creates:

EntityManagerFactory

DataSource

JpaTransactionManager
 if you dont want any certain auto configuration than, we can exclude it by

@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })
public class MyApp { ... }




Q.Role of META-INF/spring.factories in auto-configuration

It is a file used by Spring Boot‚Äôs auto-configuration mechanism. Registers auto-configuration classes so Spring Boot knows which classes to load at startup.

ex :-

org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.MyCustomAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration


During startup, Spring Boot reads this file and loads the listed classes automatically.

Q. How do you create custom starter dependencies in Spring Boot?

1. create a new maven project

2. Add spring-boot-autoconfigure dependency

3. create a Auto-Configuration class

@Configuration
public class MyCustomConfiguration{
	
    @Bean
    public MyService myService() {
        return new MyService();
    }

}


4. add this in META-INF/spring.factories

org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.autoconfig.MyCustomConfiguration


5. Publish the starter as a Maven artifact.

6. In your main Spring Boot project, add dependency:

<dependency>
    <groupId>com.example</groupId>
    <artifactId>my-custom-starter</artifactId>
</dependency>



Q. OutOfMemoryError Troubleshooting "Your Spring Boot application is suddenly throwing an OutOfMemoryError. How would you investigate and resolve it?

produce a heap dump, inspect the heap dump. Look at memory retained by an object and everything it references
look for Repeated objects that should have been garbage-collected.

Q. In a microservices-based architecture using Spring Boot, how would you handle communication failures between services?"

use resilience 4J - like timeouts, retries, circuit breakers, fallbacks.

Q. How to Secure APIs without Spring Security?

Implement a request filter (Servlet Filter or OncePerRequestFilter-like custom) that Extracts token from the (Authorization header, Bearer).
verifies the signature, check expiry, issuer, 



Q. Can a microservice have 2 databases? How to make one primary

annotate the primary datasource with @Primary annotation


@Configuration
public class DataSourceConfig {
  @Bean
  @Primary
  @ConfigurationProperties("app.datasource.primary")
  public DataSource primaryDataSource(){ ... }

  @Bean
  @ConfigurationProperties("app.datasource.secondary")
  public DataSource secondaryDataSource(){ ... }

  // Create LocalContainerEntityManagerFactoryBean and PlatformTransactionManager for each
}


Q. Does @OneToMany work for MongoDB?

@OneToMany is a JPA annotation (for relational DBs). For MongoDB (with Spring Data MongoDB) you do not use JPA mappings.

@Document(collection = "employees")
public class Employee {

    @Id
    private String id;
    private String name;
    private String position;

    public Employee() {}

    public Employee(String name, String position) {
        this.name = name;
        this.position = position;
    }

    // Getters and Setters
}

@Document(collection = "departments")
public class Department {

    @Id
    private String id;
    private String name;

    @DBRef(lazy = true) // lazy loading employees
    private List<Employee> employees;

    public Department() {}

    public Department(String name, List<Employee> employees) {
        this.name = name;
        this.employees = employees;
    }

    // Getters and Setters
}

// @DBRef tells Mongo to store only the reference emp IDS inside the department collection
instead of storing complete employee object. 


Q Sharing a request ID across microservices (A ‚Üí B ‚Üí C) without data loss


 String reqId = Optional.ofNullable(httpRequest.getHeader("X-Request-ID"))
                .orElse(UUID.randomUUID().toString());
  
@RestController
public class ServiceAController{
   
    @GetMapping("/call-b")
    public String callSeviceB()
   {
	 String reqId = UUID.randomUUID().toString());
	 HttpHeadrs headrs = new HttpHeaders();
         headers.set("X-Request-ID", requestId);

        HttpEntity<String> entity = new HttpEntity<>("Hello from A", headers);
 
        // Call Service B
        ResponseEntity<String> response = restTemplate.exchange(
                "http://localhost:8081/api/service-b/receive",
                HttpMethod.POST,
                entity,
                String.class
        );
	
	return "got response "+ response.getBody();
   }

}

@RestController
@RequestMapping("/api/service-b")
public class ServiceBController{
	
    @PostMapping("/receive")
    public ResponseEntity<String> receiveFromA(@RequestBody String body,  @RequestHeader("X-Request-ID") String reqId)
    {
	logger.info("service B received request with Id = {}, body = {}", reqId, BODY);
	return ResponseEntity.ok("processed by service B with id = "+ reqId);
    }
}

Q. distributed logging and tracing

Microservices are distributed, so logs need to be correlated across multiple services.
Without correlation, debugging an issue across multiple services becomes very hard. Generate a requestId (or X-Correlation-ID) at the first entry point (API Gateway / Service A). Collect logs from all services into a single place like Kibana, elastic search

Pass it via HTTP headers or message metadata to do	wnstream services like Service B, C, D etc

Distributed tracing
Distributed tracing follows a single request as it moves through multiple microservices.
Logs tell you what happened, but not how long each service took or how requests flow


example trace :

Request ‚Üí API Gateway (span 1, 10ms)
         ‚Üí User Service (span 2, 40ms)
         ‚Üí Order Service (span 3, 30ms)
         ‚Üí Payment Service (span 4, 120ms)


Tracing helps with:

1.Performance bottlenecks (which service is slow).

2.Failure diagnosis (where request dropped).

3. Visualization of request flows.

Tracing is done by assigning a trace ID to each request... Opentelemetry is used for standard tracing


Q. Netflix follows a microservices architecture deployed on the cloud (AWS in their case) with Spring Boot being a perfect fit if you were to build something similar:

Clients: Web, Mobile, Smart TVs

API Gateway: Handles authentication, request routing, rate limiting (e.g., Spring Cloud Gateway, Zuul)

Microservices:

User Service ‚Üí authentication, profiles, subscriptions

Catalog Service ‚Üí movies, series metadata, search

Recommendation Service ‚Üí ML-based suggestions

Streaming Service ‚Üí handles actual video delivery (CDN integration)

Billing Service ‚Üí payment, invoices

Analytics Service ‚Üí user behavior, logs

Databases: SQL + NoSQL mix (polyglot persistence)

Storage: Object storage (e.g., AWS S3) for videos

CDN (Content Delivery Network): Akamai, CloudFront, Netflix‚Äôs own Open Connect

Message Queue: Kafka, RabbitMQ for async events

Observability: Distributed tracing (Zipkin, Sleuth), Logging (ELK stack), Metrics (Prometheus + Grafana)

üîπ 2. Streaming Flow

When a user clicks play on a video:

Client requests video ‚Üí API Gateway ‚Üí Streaming Service.

Streaming Service retrieves video URL from storage (e.g., S3) + CDN.

Video files are chunked into segments (HLS/DASH).

CDN delivers chunks closest to the user (low latency).

Client continuously buffers chunks and plays seamlessly.

üëâ Streaming is NOT served directly from microservices, instead from CDN + cloud storage, because microservices can‚Äôt handle petabyte-scale video traffic.

üîπ 3. Storage of Videos

Raw video files are too large for SQL or NoSQL.

Store them in Object Storage:

AWS S3 / Google Cloud Storage / Azure Blob.

Use pre-signed URLs for secure client access.

Metadata (movie title, genre, actors, duration):

SQL DB (PostgreSQL, MySQL) for consistency (transactions).

Recommendations, tags, user watch history:

NoSQL (Cassandra, DynamoDB, MongoDB, Redis).

Search (title, actor, description):

Elasticsearch (fast indexing + text search).

üîπ 4. Database Choice

SQL (Transactional data):

User accounts, billing, subscriptions ‚Üí PostgreSQL/MySQL

NoSQL (Scalable, high-read/write data):

Watch history, likes, recommendations ‚Üí Cassandra, DynamoDB

Caching:

Redis / Memcached to reduce DB load.

üîπ 5. Handling Millions of Requests

API Gateway + Load Balancers ‚Üí scale horizontally.

Microservices deployed in Kubernetes (EKS/GKE/AKS).

Auto-scaling using cloud (scale out when traffic spikes).

CDN offloads 90%+ video streaming traffic.

Caching Layer (Redis, CDN edge nodes).

Message Queues (Kafka) ‚Üí async processing (analytics, recommendations).

Circuit Breaker & Resilience ‚Üí Netflix OSS (Hystrix), Resilience4j for fault tolerance.

Q. what is application context ?

it is a interface for accessing the Spring IOC (IOC container). it is used to manage bean instantiation, dependency injection, bean life cycle etc.

public class HelloService {
    public void sayHello() {
        System.out.println("Hello from Spring Bean!");
    }
}


import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {
    @Bean
    public HelloService helloService() {
        return new HelloService();
    }
}


ApplicationContext context = new ApplicationContext(AppConfig.class);
HelloService service = context.getBean("helloservice", HelloService.class);

service.sayHello();

Q. What is transient, volatile

transient ‚Üí Prevents a variable from being serialized.

class User implements Serializable {
   private String name;
   private transient String password; // won't be saved in file
}


volatile boolean flag = true; // updates visible to all threads


Q. Explain MVC Architecture

MVC = Model‚ÄìView‚ÄìController

Model ‚Üí Data + Business logic (Entities, Service layer in Spring).

View ‚Üí UI layer (HTML, JSP, Thymeleaf, React frontend).

Controller ‚Üí Handles user requests, interacts with Model, returns View.

üëâ In Spring MVC:

@Controller ‚Üí Defines controller classes.

@Service, @Repository ‚Üí Part of Model layer.

View ‚Üí JSP/Thymeleaf templates.



Q. application.properties file

spring.datasource.url=${DB_URL}
spring.datasource.username=${DB_USER}
spring.datasource.password=${DB_PASS}


.env file

DB_URL=jdbc:mysql://localhost:3306/mydb
DB_USER=root
DB_PASS=admin123


avoid committing .env to version control


Q.Where does a JWT server store the JWT token?
When a user logs in, the server signs a token using a secret/private key and gives it to the client (browser/mobile).
The client stores it (usually in localStorage, cookies, or mobile secure storage).

When requests come in, the server validates the signature using the same key.
There is no server-side session storage.

Q. If a table has too many indexes, what are the disadvantages?
Disadvantage	Why?
Slower INSERT/UPDATE/DELETE	Because index structures must be updated for every write.
Increased storage usage	More indexes ‚Üí more memory and disk usage.
Slower bulk operations	Insert/update batches get significantly slower.

Q. Give a case where an application cannot be deployed horizontally

Applications doing in-memory computations that require shared synchronization.

Monolithic apps that are tightly coupled and can't be broken into stateless services.

Q. There are 2 services sending mails; how to avoid duplicate emails?

Q.Types of Saga Patterns (Microservices)

Saga = sequence of local transactions with compensating actions.

Two types:
a) Choreography Saga (Event-Driven)

No central coordinator.

Each service listens for events and publishes next events.

Simpler, less coupling.

Pros: Easy, scalable.
Cons: Hard to manage complexity as services grow.

Flow example (Order Service):

OrderCreated ‚Üí InventoryService

StockReserved ‚Üí PaymentService

PaymentDone ‚Üí ShippingService

b) Orchestration Saga

A central orchestrator commands each service.

Orchestrator calls services directly, waits for responses, triggers compensations.

Pros: Central control, easier debugging.
Cons: Orchestrator becomes a dependency.

Flow:

Orchestrator ‚Üí Inventory ‚Üí Payment ‚Üí Shipping

If Payment fails ‚Üí Orchestrator triggers compensate Inventory. 
